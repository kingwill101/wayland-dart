// Generated by dart-wayland-scanner
// https://github.com/your-repo/dart-wayland-scanner
// XML file : https://gitlab.freedesktop.org/wayland/wayland-protocols/-/raw/main/staging/linux-drm-syncobj/linux-drm-syncobj-v1.xml
//
// linux_drm_syncobj_v1 Protocol Copyright: 
/// 
/// Copyright 2016 The Chromium Authors.
/// Copyright 2017 Intel Corporation
/// Copyright 2018 Collabora, Ltd
/// Copyright 2021 Simon Ser
/// 
/// Permission is hereby granted, free of charge, to any person obtaining a
/// copy of this software and associated documentation files (the "Software"),
/// to deal in the Software without restriction, including without limitation
/// the rights to use, copy, modify, merge, publish, distribute, sublicense,
/// and/or sell copies of the Software, and to permit persons to whom the
/// Software is furnished to do so, subject to the following conditions:
/// 
/// The above copyright notice and this permission notice (including the next
/// paragraph) shall be included in all copies or substantial portions of the
/// Software.
/// 
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
/// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
/// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
/// 

library client;

import 'package:wayland/wayland.dart';
import 'package:wayland/protocols/wayland.dart';
import 'dart:async';
import 'dart:convert';
import 'dart:typed_data';
import 'package:result_dart/result_dart.dart';


/// global for providing explicit synchronization
/// 
/// This global is a factory interface, allowing clients to request
/// explicit synchronization for buffers on a per-surface basis.
/// 
/// See wp_linux_drm_syncobj_surface_v1 for more information.
/// 
class WpLinuxDrmSyncobjManagerV1 extends Proxy{
  final Context innerContext;
  final version = 1;

  WpLinuxDrmSyncobjManagerV1(this.innerContext) : super(innerContext.allocateClientId()){
    innerContext.register(this);
  }


@override
toString(){
return "WpLinuxDrmSyncobjManagerV1 {name: 'wp_linux_drm_syncobj_manager_v1', id: '$objectId', version: '1',}";
}

/// destroy explicit synchronization factory object
/// 
/// Destroy this explicit synchronization factory object. Other objects
/// shall not be affected by this request.
/// 
  Result<void,Object> destroy() {
innerContext.unRegister(this);
    logLn("WpLinuxDrmSyncobjManagerV1::destroy ");
var arguments = [];var argTypes = <WaylandType>[];
var calclulatedSize  = calculateSize(argTypes, arguments);
final bytesBuilder = BytesBuilder();
bytesBuilder.add(Uint32List.fromList([objectId, (calclulatedSize << 16) | 0]).buffer.asUint8List());
    try{
    innerContext.sendMessage(bytesBuilder.toBytes(), );
    }catch (e) {
      logLn("Exception in WpLinuxDrmSyncobjManagerV1::destroy: $e");
   return Failure(e);
    }
    return Success(Object());
  }

/// extend surface interface for explicit synchronization
/// 
/// Instantiate an interface extension for the given wl_surface to provide
/// explicit synchronization.
/// 
/// If the given wl_surface already has an explicit synchronization object
/// associated, the surface_exists protocol error is raised.
/// 
/// Graphics APIs, like EGL or Vulkan, that manage the buffer queue and
/// commits of a wl_surface themselves, are likely to be using this
/// extension internally. If a client is using such an API for a
/// wl_surface, it should not directly use this extension on that surface,
/// to avoid raising a surface_exists protocol error.
/// 
/// [id]: the new synchronization surface object id
/// [surface]: the surface
  Result<WpLinuxDrmSyncobjSurfaceV1,Object> getSurface(Surface surface) {
  var id =  WpLinuxDrmSyncobjSurfaceV1(innerContext);
    logLn("WpLinuxDrmSyncobjManagerV1::getSurface  id: $id surface: $surface");
var arguments = [id, surface];var argTypes = <WaylandType>[WaylandType.newId, WaylandType.object];
var calclulatedSize  = calculateSize(argTypes, arguments);
final bytesBuilder = BytesBuilder();
bytesBuilder.add(Uint32List.fromList([objectId, (calclulatedSize << 16) | 1]).buffer.asUint8List());
    bytesBuilder.add(Uint32List.fromList([id.objectId]).buffer.asUint8List());
    bytesBuilder.add(Uint32List.fromList([surface.objectId]).buffer.asUint8List());
    try{
    innerContext.sendMessage(bytesBuilder.toBytes(), );
    }catch (e) {
      logLn("Exception in WpLinuxDrmSyncobjManagerV1::getSurface: $e");
   return Failure(e);
    }
    return Success(id);
  }

/// import a DRM syncobj timeline
/// 
/// Import a DRM synchronization object timeline.
/// 
/// If the FD cannot be imported, the invalid_timeline error is raised.
/// 
/// [id]:
/// [fd]: drm_syncobj file descriptor
  Result<WpLinuxDrmSyncobjTimelineV1,Object> importTimeline(int fd) {
  var id =  WpLinuxDrmSyncobjTimelineV1(innerContext);
    logLn("WpLinuxDrmSyncobjManagerV1::importTimeline  id: $id fd: $fd");
var arguments = [id];var argTypes = <WaylandType>[WaylandType.newId];
var calclulatedSize  = calculateSize(argTypes, arguments);
final bytesBuilder = BytesBuilder();
bytesBuilder.add(Uint32List.fromList([objectId, (calclulatedSize << 16) | 2]).buffer.asUint8List());
    bytesBuilder.add(Uint32List.fromList([id.objectId]).buffer.asUint8List());
    try{
    innerContext.sendMessage(bytesBuilder.toBytes(), fd);
    }catch (e) {
      logLn("Exception in WpLinuxDrmSyncobjManagerV1::importTimeline: $e");
   return Failure(e);
    }
    return Success(id);
  }

}

/// 
/// 

enum WpLinuxDrmSyncobjManagerV1Error {
/// the surface already has a synchronization object associated
  surfaceExists("surface_exists", 0),/// the timeline object could not be imported
  invalidTimeline("invalid_timeline", 1);
const WpLinuxDrmSyncobjManagerV1Error(this.enumName, this.enumValue);
final int enumValue;
final String enumName;
@override
toString(){
return "WpLinuxDrmSyncobjManagerV1Error {name: $enumName, value: $enumValue}";
}
}



/// synchronization object timeline
/// 
/// This object represents an explicit synchronization object timeline
/// imported by the client to the compositor.
/// 
class WpLinuxDrmSyncobjTimelineV1 extends Proxy{
  final Context innerContext;
  final version = 1;

  WpLinuxDrmSyncobjTimelineV1(this.innerContext) : super(innerContext.allocateClientId()){
    innerContext.register(this);
  }


@override
toString(){
return "WpLinuxDrmSyncobjTimelineV1 {name: 'wp_linux_drm_syncobj_timeline_v1', id: '$objectId', version: '1',}";
}

/// destroy the timeline
/// 
/// Destroy the synchronization object timeline. Other objects are not
/// affected by this request, in particular timeline points set by
/// set_acquire_point and set_release_point are not unset.
/// 
  Result<void,Object> destroy() {
innerContext.unRegister(this);
    logLn("WpLinuxDrmSyncobjTimelineV1::destroy ");
var arguments = [];var argTypes = <WaylandType>[];
var calclulatedSize  = calculateSize(argTypes, arguments);
final bytesBuilder = BytesBuilder();
bytesBuilder.add(Uint32List.fromList([objectId, (calclulatedSize << 16) | 0]).buffer.asUint8List());
    try{
    innerContext.sendMessage(bytesBuilder.toBytes(), );
    }catch (e) {
      logLn("Exception in WpLinuxDrmSyncobjTimelineV1::destroy: $e");
   return Failure(e);
    }
    return Success(Object());
  }

}



/// per-surface explicit synchronization
/// 
/// This object is an add-on interface for wl_surface to enable explicit
/// synchronization.
/// 
/// Each surface can be associated with only one object of this interface at
/// any time.
/// 
/// Explicit synchronization is guaranteed to be supported for buffers
/// created with any version of the linux-dmabuf protocol. Compositors are
/// free to support explicit synchronization for additional buffer types.
/// If at surface commit time the attached buffer does not support explicit
/// synchronization, an unsupported_buffer error is raised.
/// 
/// As long as the wp_linux_drm_syncobj_surface_v1 object is alive, the
/// compositor may ignore implicit synchronization for buffers attached and
/// committed to the wl_surface. The delivery of wl_buffer.release events
/// for buffers attached to the surface becomes undefined.
/// 
/// Clients must set both acquire and release points if and only if a
/// non-null buffer is attached in the same surface commit. See the
/// no_buffer, no_acquire_point and no_release_point protocol errors.
/// 
/// If at surface commit time the acquire and release DRM syncobj timelines
/// are identical, the acquire point value must be strictly less than the
/// release point value, or else the conflicting_points protocol error is
/// raised.
/// 
class WpLinuxDrmSyncobjSurfaceV1 extends Proxy{
  final Context innerContext;
  final version = 1;

  WpLinuxDrmSyncobjSurfaceV1(this.innerContext) : super(innerContext.allocateClientId()){
    innerContext.register(this);
  }


@override
toString(){
return "WpLinuxDrmSyncobjSurfaceV1 {name: 'wp_linux_drm_syncobj_surface_v1', id: '$objectId', version: '1',}";
}

/// destroy the surface synchronization object
/// 
/// Destroy this surface synchronization object.
/// 
/// Any timeline point set by this object with set_acquire_point or
/// set_release_point since the last commit may be discarded by the
/// compositor. Any timeline point set by this object before the last
/// commit will not be affected.
/// 
  Result<void,Object> destroy() {
innerContext.unRegister(this);
    logLn("WpLinuxDrmSyncobjSurfaceV1::destroy ");
var arguments = [];var argTypes = <WaylandType>[];
var calclulatedSize  = calculateSize(argTypes, arguments);
final bytesBuilder = BytesBuilder();
bytesBuilder.add(Uint32List.fromList([objectId, (calclulatedSize << 16) | 0]).buffer.asUint8List());
    try{
    innerContext.sendMessage(bytesBuilder.toBytes(), );
    }catch (e) {
      logLn("Exception in WpLinuxDrmSyncobjSurfaceV1::destroy: $e");
   return Failure(e);
    }
    return Success(Object());
  }

/// set the acquire timeline point
/// 
/// Set the timeline point that must be signalled before the compositor may
/// sample from the buffer attached with wl_surface.attach.
/// 
/// The 64-bit unsigned value combined from point_hi and point_lo is the
/// point value.
/// 
/// The acquire point is double-buffered state, and will be applied on the
/// next wl_surface.commit request for the associated surface. Thus, it
/// applies only to the buffer that is attached to the surface at commit
/// time.
/// 
/// If an acquire point has already been attached during the same commit
/// cycle, the new point replaces the old one.
/// 
/// If the associated wl_surface was destroyed, a no_surface error is
/// raised.
/// 
/// If at surface commit time there is a pending acquire timeline point set
/// but no pending buffer attached, a no_buffer error is raised. If at
/// surface commit time there is a pending buffer attached but no pending
/// acquire timeline point set, the no_acquire_point protocol error is
/// raised.
/// 
/// [timeline]:
/// [point_hi]: high 32 bits of the point value
/// [point_lo]: low 32 bits of the point value
  Result<void,Object> setAcquirePoint(WpLinuxDrmSyncobjTimelineV1 timeline, int pointHi, int pointLo) {
    logLn("WpLinuxDrmSyncobjSurfaceV1::setAcquirePoint  timeline: $timeline pointHi: $pointHi pointLo: $pointLo");
var arguments = [timeline, pointHi, pointLo];var argTypes = <WaylandType>[WaylandType.object, WaylandType.uint, WaylandType.uint];
var calclulatedSize  = calculateSize(argTypes, arguments);
final bytesBuilder = BytesBuilder();
bytesBuilder.add(Uint32List.fromList([objectId, (calclulatedSize << 16) | 1]).buffer.asUint8List());
    bytesBuilder.add(Uint32List.fromList([timeline.objectId]).buffer.asUint8List());
    bytesBuilder.add(Uint32List.fromList([pointHi]).buffer.asUint8List());
    bytesBuilder.add(Uint32List.fromList([pointLo]).buffer.asUint8List());
    try{
    innerContext.sendMessage(bytesBuilder.toBytes(), );
    }catch (e) {
      logLn("Exception in WpLinuxDrmSyncobjSurfaceV1::setAcquirePoint: $e");
   return Failure(e);
    }
    return Success(Object());
  }

/// set the release timeline point
/// 
/// Set the timeline point that must be signalled by the compositor when it
/// has finished its usage of the buffer attached with wl_surface.attach
/// for the relevant commit.
/// 
/// Once the timeline point is signaled, and assuming the associated buffer
/// is not pending release from other wl_surface.commit requests, no
/// additional explicit or implicit synchronization with the compositor is
/// required to safely re-use the buffer.
/// 
/// Note that clients cannot rely on the release point being always
/// signaled after the acquire point: compositors may release buffers
/// without ever reading from them. In addition, the compositor may use
/// different presentation paths for different commits, which may have
/// different release behavior. As a result, the compositor may signal the
/// release points in a different order than the client committed them.
/// 
/// Because signaling a timeline point also signals every previous point,
/// it is generally not safe to use the same timeline object for the
/// release points of multiple buffers. The out-of-order signaling
/// described above may lead to a release point being signaled before the
/// compositor has finished reading. To avoid this, it is strongly
/// recommended that each buffer should use a separate timeline for its
/// release points.
/// 
/// The 64-bit unsigned value combined from point_hi and point_lo is the
/// point value.
/// 
/// The release point is double-buffered state, and will be applied on the
/// next wl_surface.commit request for the associated surface. Thus, it
/// applies only to the buffer that is attached to the surface at commit
/// time.
/// 
/// If a release point has already been attached during the same commit
/// cycle, the new point replaces the old one.
/// 
/// If the associated wl_surface was destroyed, a no_surface error is
/// raised.
/// 
/// If at surface commit time there is a pending release timeline point set
/// but no pending buffer attached, a no_buffer error is raised. If at
/// surface commit time there is a pending buffer attached but no pending
/// release timeline point set, the no_release_point protocol error is
/// raised.
/// 
/// [timeline]:
/// [point_hi]: high 32 bits of the point value
/// [point_lo]: low 32 bits of the point value
  Result<void,Object> setReleasePoint(WpLinuxDrmSyncobjTimelineV1 timeline, int pointHi, int pointLo) {
    logLn("WpLinuxDrmSyncobjSurfaceV1::setReleasePoint  timeline: $timeline pointHi: $pointHi pointLo: $pointLo");
var arguments = [timeline, pointHi, pointLo];var argTypes = <WaylandType>[WaylandType.object, WaylandType.uint, WaylandType.uint];
var calclulatedSize  = calculateSize(argTypes, arguments);
final bytesBuilder = BytesBuilder();
bytesBuilder.add(Uint32List.fromList([objectId, (calclulatedSize << 16) | 2]).buffer.asUint8List());
    bytesBuilder.add(Uint32List.fromList([timeline.objectId]).buffer.asUint8List());
    bytesBuilder.add(Uint32List.fromList([pointHi]).buffer.asUint8List());
    bytesBuilder.add(Uint32List.fromList([pointLo]).buffer.asUint8List());
    try{
    innerContext.sendMessage(bytesBuilder.toBytes(), );
    }catch (e) {
      logLn("Exception in WpLinuxDrmSyncobjSurfaceV1::setReleasePoint: $e");
   return Failure(e);
    }
    return Success(Object());
  }

}

/// 
/// 

enum WpLinuxDrmSyncobjSurfaceV1Error {
/// the associated wl_surface was destroyed
  noSurface("no_surface", 1),/// the buffer does not support explicit synchronization
  unsupportedBuffer("unsupported_buffer", 2),/// no buffer was attached
  noBuffer("no_buffer", 3),/// no acquire timeline point was set
  noAcquirePoint("no_acquire_point", 4),/// no release timeline point was set
  noReleasePoint("no_release_point", 5),/// acquire and release timeline points are in conflict
  conflictingPoints("conflicting_points", 6);
const WpLinuxDrmSyncobjSurfaceV1Error(this.enumName, this.enumValue);
final int enumValue;
final String enumName;
@override
toString(){
return "WpLinuxDrmSyncobjSurfaceV1Error {name: $enumName, value: $enumValue}";
}
}

