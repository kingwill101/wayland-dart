// Generated by dart-wayland-scanner
// https://github.com/your-repo/dart-wayland-scanner
// XML file : https://gitlab.freedesktop.org/wayland/wayland-protocols/-/raw/main/staging/cursor-shape/cursor-shape-v1.xml
//
// cursor_shape_v1 Protocol Copyright: 
/// 
/// Copyright 2018 The Chromium Authors
/// Copyright 2023 Simon Ser
/// 
/// Permission is hereby granted, free of charge, to any person obtaining a
/// copy of this software and associated documentation files (the "Software"),
/// to deal in the Software without restriction, including without limitation
/// the rights to use, copy, modify, merge, publish, distribute, sublicense,
/// and/or sell copies of the Software, and to permit persons to whom the
/// Software is furnished to do so, subject to the following conditions:
/// The above copyright notice and this permission notice (including the next
/// paragraph) shall be included in all copies or substantial portions of the
/// Software.
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
/// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
/// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
/// 

library client;

import 'package:wayland/wayland.dart';
import 'package:wayland/protocols/wayland.dart';
import 'package:wayland/protocols/stable/tablet/tablet_v2.dart';
import 'dart:async';
import 'dart:convert';
import 'dart:typed_data';
import 'package:result_dart/result_dart.dart';


/// cursor shape manager
/// 
/// This global offers an alternative, optional way to set cursor images. This
/// new way uses enumerated cursors instead of a wl_surface like
/// wl_pointer.set_cursor does.
/// 
/// Warning! The protocol described in this file is currently in the testing
/// phase. Backward compatible changes may be added together with the
/// corresponding interface version bump. Backward incompatible changes can
/// only be done by creating a new major version of the extension.
/// 
class WpCursorShapeManagerV1 extends Proxy{
  final Context innerContext;
  final version = 1;

  WpCursorShapeManagerV1(this.innerContext) : super(innerContext.allocateClientId()){
    innerContext.register(this);
  }


@override
toString(){
return "WpCursorShapeManagerV1 {name: 'wp_cursor_shape_manager_v1', id: '$objectId', version: '1',}";
}

/// destroy the manager
/// 
/// Destroy the cursor shape manager.
/// 
  Result<void,Object> destroy() {
innerContext.unRegister(this);
    logLn("WpCursorShapeManagerV1::destroy ");
var arguments = [];var argTypes = <WaylandType>[];
var calclulatedSize  = calculateSize(argTypes, arguments);
final bytesBuilder = BytesBuilder();
bytesBuilder.add(Uint32List.fromList([objectId, (calclulatedSize << 16) | 0]).buffer.asUint8List());
    try{
    innerContext.sendMessage(bytesBuilder.toBytes(), );
    }catch (e) {
      logLn("Exception in WpCursorShapeManagerV1::destroy: $e");
   return Failure(e);
    }
    return Success(Object());
  }

/// manage the cursor shape of a pointer device
/// 
/// Obtain a wp_cursor_shape_device_v1 for a wl_pointer object.
/// 
/// [cursor_shape_device]:
/// [pointer]:
  Result<WpCursorShapeDeviceV1,Object> getPointer(Pointer pointer) {
  var cursorShapeDevice =  WpCursorShapeDeviceV1(innerContext);
    logLn("WpCursorShapeManagerV1::getPointer  cursorShapeDevice: $cursorShapeDevice pointer: $pointer");
var arguments = [cursorShapeDevice, pointer];var argTypes = <WaylandType>[WaylandType.newId, WaylandType.object];
var calclulatedSize  = calculateSize(argTypes, arguments);
final bytesBuilder = BytesBuilder();
bytesBuilder.add(Uint32List.fromList([objectId, (calclulatedSize << 16) | 1]).buffer.asUint8List());
    bytesBuilder.add(Uint32List.fromList([cursorShapeDevice.objectId]).buffer.asUint8List());
    bytesBuilder.add(Uint32List.fromList([pointer.objectId]).buffer.asUint8List());
    try{
    innerContext.sendMessage(bytesBuilder.toBytes(), );
    }catch (e) {
      logLn("Exception in WpCursorShapeManagerV1::getPointer: $e");
   return Failure(e);
    }
    return Success(cursorShapeDevice);
  }

/// manage the cursor shape of a tablet tool device
/// 
/// Obtain a wp_cursor_shape_device_v1 for a zwp_tablet_tool_v2 object.
/// 
/// [cursor_shape_device]:
/// [tablet_tool]:
  Result<WpCursorShapeDeviceV1,Object> getTabletToolV2(ZwpTabletToolV2 tabletTool) {
  var cursorShapeDevice =  WpCursorShapeDeviceV1(innerContext);
    logLn("WpCursorShapeManagerV1::getTabletToolV2  cursorShapeDevice: $cursorShapeDevice tabletTool: $tabletTool");
var arguments = [cursorShapeDevice, tabletTool];var argTypes = <WaylandType>[WaylandType.newId, WaylandType.object];
var calclulatedSize  = calculateSize(argTypes, arguments);
final bytesBuilder = BytesBuilder();
bytesBuilder.add(Uint32List.fromList([objectId, (calclulatedSize << 16) | 2]).buffer.asUint8List());
    bytesBuilder.add(Uint32List.fromList([cursorShapeDevice.objectId]).buffer.asUint8List());
    bytesBuilder.add(Uint32List.fromList([tabletTool.objectId]).buffer.asUint8List());
    try{
    innerContext.sendMessage(bytesBuilder.toBytes(), );
    }catch (e) {
      logLn("Exception in WpCursorShapeManagerV1::getTabletToolV2: $e");
   return Failure(e);
    }
    return Success(cursorShapeDevice);
  }

}



/// cursor shape for a device
/// 
/// This interface allows clients to set the cursor shape.
/// 
class WpCursorShapeDeviceV1 extends Proxy{
  final Context innerContext;
  final version = 1;

  WpCursorShapeDeviceV1(this.innerContext) : super(innerContext.allocateClientId()){
    innerContext.register(this);
  }


@override
toString(){
return "WpCursorShapeDeviceV1 {name: 'wp_cursor_shape_device_v1', id: '$objectId', version: '1',}";
}

/// destroy the cursor shape device
/// 
/// Destroy the cursor shape device.
/// 
/// The device cursor shape remains unchanged.
/// 
  Result<void,Object> destroy() {
innerContext.unRegister(this);
    logLn("WpCursorShapeDeviceV1::destroy ");
var arguments = [];var argTypes = <WaylandType>[];
var calclulatedSize  = calculateSize(argTypes, arguments);
final bytesBuilder = BytesBuilder();
bytesBuilder.add(Uint32List.fromList([objectId, (calclulatedSize << 16) | 0]).buffer.asUint8List());
    try{
    innerContext.sendMessage(bytesBuilder.toBytes(), );
    }catch (e) {
      logLn("Exception in WpCursorShapeDeviceV1::destroy: $e");
   return Failure(e);
    }
    return Success(Object());
  }

/// set device cursor to the shape
/// 
/// Sets the device cursor to the specified shape. The compositor will
/// change the cursor image based on the specified shape.
/// 
/// The cursor actually changes only if the input device focus is one of
/// the requesting client's surfaces. If any, the previous cursor image
/// (surface or shape) is replaced.
/// 
/// The "shape" argument must be a valid enum entry, otherwise the
/// invalid_shape protocol error is raised.
/// 
/// This is similar to the wl_pointer.set_cursor and
/// zwp_tablet_tool_v2.set_cursor requests, but this request accepts a
/// shape instead of contents in the form of a surface. Clients can mix
/// set_cursor and set_shape requests.
/// 
/// The serial parameter must match the latest wl_pointer.enter or
/// zwp_tablet_tool_v2.proximity_in serial number sent to the client.
/// Otherwise the request will be ignored.
/// 
/// [serial]: serial number of the enter event
/// [shape]:
  Result<void,Object> setShape(int serial, int shape) {
    logLn("WpCursorShapeDeviceV1::setShape  serial: $serial shape: $shape");
var arguments = [serial, shape];var argTypes = <WaylandType>[WaylandType.uint, WaylandType.uint];
var calclulatedSize  = calculateSize(argTypes, arguments);
final bytesBuilder = BytesBuilder();
bytesBuilder.add(Uint32List.fromList([objectId, (calclulatedSize << 16) | 1]).buffer.asUint8List());
    bytesBuilder.add(Uint32List.fromList([serial]).buffer.asUint8List());
    bytesBuilder.add(Uint32List.fromList([shape]).buffer.asUint8List());
    try{
    innerContext.sendMessage(bytesBuilder.toBytes(), );
    }catch (e) {
      logLn("Exception in WpCursorShapeDeviceV1::setShape: $e");
   return Failure(e);
    }
    return Success(Object());
  }

}

/// cursor shapes
/// 
/// This enum describes cursor shapes.
/// 
/// The names are taken from the CSS W3C specification:
/// https://w3c.github.io/csswg-drafts/css-ui/#cursor
/// 

enum WpCursorShapeDeviceV1Shape {
/// default cursor
  defaulted("default", 1),/// a context menu is available for the object under the cursor
  contextMenu("context_menu", 2),/// help is available for the object under the cursor
  help("help", 3),/// pointer that indicates a link or another interactive element
  pointer("pointer", 4),/// progress indicator
  progress("progress", 5),/// program is busy, user should wait
  wait("wait", 6),/// a cell or set of cells may be selected
  cell("cell", 7),/// simple crosshair
  crosshair("crosshair", 8),/// text may be selected
  text("text", 9),/// vertical text may be selected
  verticalText("vertical_text", 10),/// drag-and-drop: alias of/shortcut to something is to be created
  alias("alias", 11),/// drag-and-drop: something is to be copied
  copy("copy", 12),/// drag-and-drop: something is to be moved
  move("move", 13),/// drag-and-drop: the dragged item cannot be dropped at the current cursor location
  noDrop("no_drop", 14),/// drag-and-drop: the requested action will not be carried out
  notAllowed("not_allowed", 15),/// drag-and-drop: something can be grabbed
  grab("grab", 16),/// drag-and-drop: something is being grabbed
  grabbing("grabbing", 17),/// resizing: the east border is to be moved
  eResize("e_resize", 18),/// resizing: the north border is to be moved
  nResize("n_resize", 19),/// resizing: the north-east corner is to be moved
  neResize("ne_resize", 20),/// resizing: the north-west corner is to be moved
  nwResize("nw_resize", 21),/// resizing: the south border is to be moved
  sResize("s_resize", 22),/// resizing: the south-east corner is to be moved
  seResize("se_resize", 23),/// resizing: the south-west corner is to be moved
  swResize("sw_resize", 24),/// resizing: the west border is to be moved
  wResize("w_resize", 25),/// resizing: the east and west borders are to be moved
  ewResize("ew_resize", 26),/// resizing: the north and south borders are to be moved
  nsResize("ns_resize", 27),/// resizing: the north-east and south-west corners are to be moved
  neswResize("nesw_resize", 28),/// resizing: the north-west and south-east corners are to be moved
  nwseResize("nwse_resize", 29),/// resizing: that the item/column can be resized horizontally
  colResize("col_resize", 30),/// resizing: that the item/row can be resized vertically
  rowResize("row_resize", 31),/// something can be scrolled in any direction
  allScroll("all_scroll", 32),/// something can be zoomed in
  zoomIn("zoom_in", 33),/// something can be zoomed out
  zoomOut("zoom_out", 34);
const WpCursorShapeDeviceV1Shape(this.enumName, this.enumValue);
final int enumValue;
final String enumName;
@override
toString(){
return "WpCursorShapeDeviceV1Shape {name: $enumName, value: $enumValue}";
}
}

/// 
/// 

enum WpCursorShapeDeviceV1Error {
/// the specified shape value is invalid
  invalidShape("invalid_shape", 1);
const WpCursorShapeDeviceV1Error(this.enumName, this.enumValue);
final int enumValue;
final String enumName;
@override
toString(){
return "WpCursorShapeDeviceV1Error {name: $enumName, value: $enumValue}";
}
}

